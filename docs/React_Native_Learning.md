# React Native Learning ## CommandsCommand to Create an Expo App```bashnpx create-expo-app@latest FirstApp --template ```Command to install SafeAreaView```bashnpm install react-native-safe-area-context ```Command to support web run```bashnpx expo install react-dom react-native-web```Command to launch App on Expo Go```bashnpx expo start```Command to launch App on Web(Browser)```bashnpm start```### To fix the NPM expo sdk versionUpgrade the Expo Sdk```bashnpm install expo@^54.0.0```Upgrade dependencies```bashnpx expo install --fix``````bashnpx expo-doctor```### Clean up the Workspace#### 1) Stop any running node/Metro processes```bashtaskkill /F /IM node.exe /T 2>$null```#### 2) Clean stale artifacts```bashrmdir node_modules``````bashdel package-lock.json``````bashrmdir .expo``````bashnpm cache clean --force```#### 3) Install fresh```bashnpm install```#### 4) Let Expo align anything else to SDK 54’s matrix```bashnpx expo install --fix```#### 5) Optional health check```bashnpx expo-doctor```#### 6) Run```bashnpx expo start -c```## Form ValidationsUse form hook and yup library```bashnpm install react-hook-form``````bashnpm install yup```## Firebase```bashnpx expo install firebase```#### Step 1) create `firebase.js` config file```typescript// Import the functions you need from the SDKs you needimport { initializeApp } from "firebase/app";// TODO: Add SDKs for Firebase products that you want to use// https://firebase.google.com/docs/web/setup#available-libraries// Your web app's Firebase configurationconst firebaseConfig = {    apiKey: "AIzaSyAAvTf90gPtwvc286DPn9stq3mQbFC7fiw",    authDomain: "smart-e-commerce-app-6b050.firebaseapp.com",    projectId: "smart-e-commerce-app-6b050",    storageBucket: "smart-e-commerce-app-6b050.firebasestorage.app",    messagingSenderId: "637648108379",    appId: "1:637648108379:web:d4d50fe6f7595d671d387e"};```#### Step 2) Initialize Firebase```typescriptconst app = initializeApp(firebaseConfig);```#### Required for firebase version 9 and above```bashnpx expo customize metro.config.js```#### `metro.config.json` file```typescriptconst { getDefaultConfig } = require('@expo/metro-config');const defaultConfig = getDefaultConfig(dirname);// Add 'cjs' to the list of source extensions to properly bundle Firebase v9+defaultConfig.resolver.sourceExts.push('cjs');module.exports = defaultConfig;```## Localization Link - https://react.i18next.com/```bashnpm install i18next``````bashnpm install react-i18next```## Local StorageReact Native Async Storage – https://www.npmjs.com/package/@react-native-async-storage/async-storage```bashnpx expo install @react-native-async-storage/async-storage```Redux Persist - https://www.npmjs.com/package/redux-persist```bashnpm install redux-persist```## Deployment with EAS CLI#### a) Install and loginInstall EAS CLI:```bashnpm install -g eas-cli```Login to your Expo account (create one at expo.dev if needed): ```basheas login```To generate // Important step```basheas expo install --check``````basheas build -p android --profile preview```#### b) Ensure app config has Android packageIn `app.json` or `app.config.js`:```JSON{ "expo": { "name": "MyApp", "slug": "my-app", "android": { "package": "com.yourcompany.myapp", "versionCode": 1 }} }```#### c) Configure EAS for your project (creates eas.json)From project root:```basheas build:configure```(This helps set up eas.json and guides through minimal configuration)#### d) Edit `eas.json` (example with APK profile)Create or update eas.json with a preview profile for APK (useful for direct install), and production profile for aab (Play Store):Example of `eas.json`:```JSON{  "cli": {    "version": ">= 16.28.0",    "appVersionSource": "remote"  },  "build": {    "development": {      "developmentClient": true,      "distribution": "internal",      "ios": {        "simulator": true      },      "android": {        "buildType": "apk"      }    },    "preview": {      "distribution": "internal",      "ios": {        "simulator": true      },      "android": {        "buildType": "apk"      }    },    "production": {      "autoIncrement": true,      "android": {        "buildType": "app-bundle"      }    }  },  "submit": {    "production": {}  }}```buildType "apk" produces an installable APK artifact; "app-bundle" produces a .aab for Play Store.#### e) Start a build (APK for direct install)```basheas build --platform android --profile preview```Or for production App Bundle: ```basheas build --platform android --profile production```#### f) Signing / CredentialsDuring the build EAS will ask whether you want EAS to manage Android credentials (keystore). For most workflows, allow EAS to manage (simpler). You can also provide your own keystore (choose manual).You can run ```basheas credentials to view/manage credentials.```#### g) Download artifact & installAfter the build finishes, EAS prints a download URL in the terminal and in your Expo dashboard at https://expo.dev/accounts/<your-account>/projects/<your-project>/builds.Download the .apk file to your computer or directly open from device.Install via adb:```bashadb install -r path/to/your-app.apk```Or open the downloaded APK on the Android device and follow prompts (allow installs from unknown sources if necessary).### Set up GitHub Actions WorkflowsIn `.github/workflows/` directory- Example of `unit-tests.yml````yamlname: Unit Testson:  pull_request:    branches:      - "**"jobs:  test:    runs-on: ubuntu-latest    steps:      - name: Checkout        uses: actions/checkout@v4      - name: Setup Node        uses: actions/setup-node@v4        with:          node-version: "20"          cache: "npm"      - name: Install dependencies        run: npm ci      - name: Run unit tests        run: npm test  lint:    runs-on: ubuntu-latest    steps:      - name: Checkout        uses: actions/checkout@v4      - name: Setup Node        uses: actions/setup-node@v4        with:          node-version: "20"          cache: "npm"      - name: Install dependencies        run: npm ci      - name: Run lint        run: npm run lint```### Set up EAS CLI WorkflowsIn `.eas/workflows/` directory- Example of `create-development-builds.yml````yamlname: Create Development Buildson:  push:    branches:      - developjobs:  android_development_builds:    name: Build Android    type: build    params:      platform: android      profile: development  ios_development_builds:    name: Build iOS device    type: build    params:      platform: ios      profile: development```- Example of `publish-preview-update.yml````yamlname: Publish Preview Updateon:  push:    branches:      - masterjobs:  publish_preview_update:    name: Publish Preview Update    type: update    params:      branch: ${{ github.ref_name }}      message: "Preview update from EAS Workflow"      platform: all```Example of `deploy-to-production.yml````yamlname: Deploy to Productionon:  push:    branches:      - mainjobs:  build_android:    name: Build Android    type: build    params:      platform: android      profile: production  build_ios:    name: Build iOS    type: build    params:      platform: ios      profile: production  submit_android:    name: Submit Android    type: submit    needs:      - build_android    params:      platform: android      profile: production  submit_ios:    name: Submit iOS    type: submit    needs:      - build_ios    params:      platform: ios      profile: production```## Android & iOS Developer accounts to publish apps### Android:- Create Account - https://www.youtube.com/watch?v=78\_GQmXLzlQ&t=28s- Publish App - https://www.youtube.com/watch?v=d8uEdeMgikUAndroid:### iOS / Apple:- Create Account - https://www.youtube.com/watch?v=vp8Z2w3gJD0- Publish App - https://www.youtube.com/watch?v=NcQYhZlIePM## Setting Up React Native CLILink: https://reactnative.dev/Follow these steps to set up React Native CLI for your project:### Prerequisites- Install Node.js (version 18 or newer) from the Node.js website.- Install Java Development Kit (JDK) version 17. You can use OpenJDK or Azul Zulu.- Install Android Studio for Android development: During installation, ensure the following components are selected: Android SDK Android SDK Platform Android Virtual Device (AVD) Open Android Studio, go to More Actions > SDK Manager, and install the required SDK tools.- Set up environment variables for Android: Add the following lines to your shell configuration file (e.g., ~/.zshrc or ~/.bash_profile): export ANDROID_HOME=$HOME/Android/Sdk export PATH=$PATH:$ANDROID_HOME/emulator export PATH=$PATH:$ANDROID_HOME/platform-tools Run source ~/.zshrc (or source ~/.bash_profile) to apply changes.- Install Watchman (optional but recommended for better performance).### Creating a New React Native ProjectOpen a terminal and run:```bashnpx @react-native-community/cli init NewProjectName```Navigate to the project directory:```bashcd NewProjectName```Start the Metro Bundler:```bashnpm start```### Running the Project#### For Android: Connect an Android device or start an emulator using Android Studio. Run the app:```bashnpx react-native run-android```#### For iOS (macOS required):Install Xcode from the Mac App Store. Open Xcode and install the necessary command-line tools. Run the app:```bashnpx react-native run-ios```You are now ready to start building your React Native app.## Firebase chat app#### Setup Firebase notificationsFor Google Signin - https://react-native-google-signin.github.io/docs/install```bashyarn add @react-native-google-signin/google-signin```Code:```typescriptimport { GoogleSignin } from '@react-native-google-signin/google-signin';useEffect(() => {  GoogleSignin.configure({    webClientId: 'YOUR_WEB_CLIENT_ID',     iosClientId: 'YOUR_IOS_CLIENT_ID', // if applicable  });}, []);// ...```## Image Picker To implement an image picker in React Native, the most common approaches involve using either the community-maintained library react-native-image-picker for bare React Native projects or expo-image-picker for projects within the Expo ecosystem.Using react-native-image-pickerThis library provides access to the native camera and gallery UI for both iOS and Android. #### 1. InstallationInstall the package using npm or yarn:```bashnpm install react-native-image-picker```or```bashyarn add react-native-image-picker```For iOS, you also need to install the CocoaPods:```bashcd ios && pod install```Auto-linking handles most of the native configuration for React Native versions 0.60+. #### 2. Configure PermissionsYou must add usage descriptions to your iOS Info.plist file and potentially add camera permission to your Android AndroidManifest.xml (though runtime permissions are also necessary for Android 29+). iOS (ios/YourProjectName/Info.plist):```xml<key>NSPhotoLibraryUsageDescription</key><string>$(PRODUCT_NAME) would like access to your photo gallery to select an image.</string><key>NSCameraUsageDescription</key><string>$(PRODUCT_NAME) would like to use your camera to take a photo.</string><key>NSMicrophoneUsageDescription</key><string>$(PRODUCT_NAME) would like to use your microphone to record videos.</string>```Android (android/app/src/main/AndroidManifest.xml - camera permission is needed for launchCamera):```xml<uses-permission android:name="android.permission.CAMERA" /><!-- Permissions for storage access are auto-handled for Android 33+ -->```#### 3. Usage Example (Functional Component)You can use launchCamera and launchImageLibrary as promises (async/await) or with a callback. ```tsximport React, {useState} from 'react';import {Button, Image, View, StyleSheet, Alert} from 'react-native';import {launchCamera, launchImageLibrary} from 'react-native-image-picker';const ImagePickerComponent = () => {  const [imageUri, setImageUri] = useState(null);  const options = {    mediaType: 'photo',    quality: 0.8,    includeBase64: false,  };  const openCamera = async () => {    const result = await launchCamera(options);    if (result.didCancel) {      console.log('User cancelled camera');    } else if (result.errorCode) {      console.log('Camera Error:', result.errorMessage);    } else if (result.assets && result.assets.length > 0) {      setImageUri(result.assets[0].uri);    }  };  const openImageLibrary = async () => {    const result = await launchImageLibrary(options);    if (result.didCancel) {      console.log('User cancelled image library');    } else if (result.errorCode) {      console.log('Image Library Error:', result.errorMessage);    } else if (result.assets && result.assets.length > 0) {      setImageUri(result.assets[0].uri);    }  };  return (    <View style={styles.container}>      <Button title="Open Camera" onPress={openCamera}/>      <Button title="Select from Gallery" onPress={openImageLibrary}/>      {imageUri && (        <Image source={{uri: imageUri}} style={styles.image}/>      )}    </View>  );};const styles = StyleSheet.create({  container: {    flex: 1,    justifyContent: 'center',    alignItems: 'center',    padding: 20,  },  image: {    width: 200,    height: 200,    marginTop: 20,  },});export default ImagePickerComponent;```For more detailed documentation and options, refer to the react-native-image-picker GitHub repository.Using expo-image-picker (for Expo projects)If you are using Expo, expo-image-picker is the recommended and simpler solution as it handles native configurations automatically. #### 1. Installation```bashnpx expo install expo-image-picker```#### 2. Usage ExampleThe launchImageLibraryAsync function is asynchronous and returns an object containing the URI of the selected image. ```tsximport React, {useState} from 'react';import {Button, Image, View, StyleSheet} from 'react-native';import * as ImagePicker from 'expo-image-picker';const ExpoImagePickerComponent = () => {  const [imageUri, setImageUri] = useState(null);    const pickImageAsync = async () => {    let result = await ImagePicker.launchImageLibraryAsync({      mediaTypes: ImagePicker.MediaTypeOptions.Images,      allowsEditing: true,      aspect: [4, 3],      quality: 1,  });        if (!result.canceled) {      setImageUri(result.assets[0].uri);    } else {      alert('You did not select any image.');    }  };    return (    <View style={styles.container}>      <Button title="Pick an image from gallery" onPress={pickImageAsync}/>      {imageUri && (<Image source={{uri: imageUri}} style={styles.image}/>)}    </View>  );};const styles = StyleSheet.create({  container: {    flex: 1,    alignItems: 'center',    justifyContent: 'center',  },  image: {    width: 200,    height: 200,    marginTop: 20,  },});export default ExpoImagePickerComponent;```For detailed information on options and permissions within the Expo ecosystem, visit the [Expo ImagePicker Documentation](https://docs.expo.dev/versions/latest/sdk/imagepicker/). ## Splash screenLink - https://github.com/zoontek/react-native-bootsplashIntegrating a splash screen in a React Native app with [react-native-bootsplash](https://github.com/zoontek/react-native-bootsplash) involves installing the package, generating native assets, configuring native files for both iOS and Android, and finally controlling the splash screen's visibility from JavaScript. #### 1. InstallationInstall the library using npm or yarn and install the pods for iOS: ```bashnpm install --save react-native-bootsplash && cd ios && pod install```or```bashyarn add react-native-bootsplash && cd ios && pod install```#### 2. Generate Native AssetsUse the CLI command to generate the necessary images and configuration files for both platforms. Replace the path, background color, and logo width with your specific details:```bashnpx react-native generate-bootsplash <path/to/your/logo.png> --platforms=android,ios --background="#FFFFFF" --logo-width=100```This command generates the required image assets, a BootSplash.storyboard file for iOS, and a bootsplash.xml file for Android. #### 3. Configure Native Files#### iOS Setup- Open your project in Xcode and drag the generated BootSplash.storyboard file into the project navigator (make sure your app target is selected in the "Add to Targets" option).- In your project's build settings, ensure the Launch Screen File property is set to BootSplash.- Edit ios/<YourAppName>/AppDelegate.mm (or .m):- Add the import statement: #import "RNBootSplash.h".- Initialize the splash screen within the didFinishLaunchingWithOptions method, just before return YES;:```objective-c[RNBootSplash initWithStoryboard:@"BootSplash" rootView:rootView]; // ⬅️ initialize the splash screenreturn YES;```#### Android Setup- Configuration for Android involves modifying styles.xml to add a BootTheme, updating AndroidManifest.xml to use the BootTheme and adjust activity setup, and adding initialization code in MainActivity.java or .kt. #### 4. Control from JavaScriptControl the splash screen's visibility from JavaScript. Use useEffect in your main app component or the onReady prop with React Navigation's NavigationContainer to call RNBootSplash.hide() when your app is ready. ## Google Maps The standard way to integrate Google Maps into a React Native application is by using the community-developed react-native-maps library, as there is no official Google Maps library for general map display in React Native. The official documentation for this library, including installation and configuration instructions, can be found in its GitHub documentation. ### Step-by-Step Integration Guide#### 1. Install the LibraryUse npm or Yarn to add the package to your project:```bashnpm install react-native-maps```or```bashyarn add react-native-maps```After installation, navigate to the ios directory and install the CocoaPods:```bashcd ios && pod install```#### 2. Obtain a Google Maps API Key You must have a Google Cloud project with a billing account enabled to use the Maps SDKs. Visit the Google Cloud Platform Console and create a new project.* In the APIs & Services > Library section, enable the Maps SDK for Android and the Maps SDK for iOS.* In the APIs & Services > Credentials section, create an API key.Remember to restrict your API key (e.g., to your app's bundle identifiers and package names) to prevent unauthorized use. #### 3. Configure for iOSTo enable Google Maps specifically on iOS, you need to edit the AppDelegate.m file in your Xcode project: - Add the import statement `#import <GoogleMaps/GoogleMaps.h>`- Add `[GMSServices provideAPIKey:@"YOUR_API_KEY"];` as the first line inside the `didFinishLaunchingWithOptions` method.- Ensure your iOS deployment target is set to iOS 14 or higher in your Podfile and Xcode project settings.- Add a `NSLocationWhenInUseUsageDescription` to your app's `Info.plist` file, explaining why your app needs location access. #### 4. Configure for Android- Add your Google Maps API key to your `AndroidManifest.xml` file located in `android/app/src/main/`: - Place the following <meta-data> tag inside the <application> tag, replacing "Your Google maps API Key Here" with your actual key. - The Android configuration involves adding your Google Maps API key to the AndroidManifest.xml file within the <application> tag. The required code snippet for this step, along with further details on how to integrate and display the map using the MapView component in your React Native code, can be found in the [react-native-maps GitHub documentation](https://github.com/react-native-maps/react-native-maps/blob/master/docs/installation.md) and [react-native-maps GitHub documentation](https://github.com/react-native-maps/react-native-maps/blob/master/docs/mapview.md) respectively. ## Command shortcutsAdd short commands under `package.json` file```JSON{    "scripts": {      // existing      "android": "react-native run-android",      "ios": "react-native run-ios",      "lint": "eslint .",      "start": "react-native start",      "test": "jest",      "both": "react-native run-android && react-native run-ios",      "g-c-run": "cd android && ./gradlew clean && cd .. && react-native run-android",      "g-clean": "cd android && ./gradlew clean && cd ..",      "pod": "cd ios && pod install && cd ..",      "open-xcode": "xed -b ios",      "new-blood": "rm -rf node_modules && rm -rf yarn.lock && cd ios && rm -rf Podfile.lock && pod install && cd .. && yarn install",            // metro / cache      "start:reset": "react-native start --reset-cache",      "clean:metro-cache": "rm -rf $TMPDIR/metro-*",      "clean:watchman": "watchman watch-del-all || true",            // lint / format / types      "lint:fix": "eslint . --fix",      "format": "prettier --write \"/*/*/*.{js,jsx,ts,tsx,json,md}\"",      "typecheck": "tsc --noEmit",        // android      "android:clean": "cd android && ./gradlew clean && cd ..",      "android:debug": "cd android && ./gradlew assembleDebug",      "android:release": "cd android && ./gradlew assembleRelease",      "android:bundle:release": "cd android && ./gradlew bundleRelease",      "android:install:debug": "cd android && ./gradlew installDebug",      "android:uninstall:debug": "cd android && ./gradlew uninstallDebug",            // ios (macOS)      "pods:install": "cd ios && pod install && cd ..",      "pods:reinstall": "cd ios && rm -rf Pods Podfile.lock && pod install && cd ..",      "ios:deriveddata:clean": "rm -rf ~/Library/Developer/Xcode/DerivedData/*",      "ios:build:debug": "xcodebuild -workspace ios/*.xcworkspace -scheme <YourScheme> -configuration Debug -sdk iphonesimulator -derivedDataPath ios/build",      "ios:build:release": "xcodebuild -workspace ios/*.xcworkspace -scheme <YourScheme> -configuration Release -sdk iphoneos -derivedDataPath ios/build",            // reinstall / housekeeping      "clean": "rm -rf node_modules && rm -rf yarn.lock && yarn cache clean",      "reinstall": "rm -rf node_modules && rm -rf yarn.lock && yarn install",      "reinstall:pods": "rm -rf node_modules && rm -rf yarn.lock && yarn install && yarn pods:reinstall",            // tests      "test:watch": "jest --watch",      "test:coverage": "jest --coverage",      // fresh flows      "fresh:android": "yarn clean && yarn android:clean && yarn pods:install && yarn start:reset && yarn android",      "fresh:ios": "yarn clean && yarn pods:reinstall && yarn ios:deriveddata:clean && yarn start:reset && yarn ios"    }}```#### Notes & small improvements- Your both will try to run Android and iOS simultaneously in the same shell; that can be noisy. If you need parallelism, consider concurrently:```bashyarn add -D concurrently``````JSON{  "scripts": {    "both": "concurrently -k -n ANDROID,IOS \"yarn android\" \"yarn ios\""  }}```- The open-xcode (xed -b ios) works only on macOS.- If you’re on Windows for Android work, all Android scripts work; iOS ones will be ignored.## Publish React Native CLI app on AppStoreVideo Link: https://www.youtube.com/watch?v=r-Z--YDrmjI## OTA - On the Air Updates for React Native app using [Stallion](https://www.stalliontech.io/)To provide Over-the-Air (OTA) updates for a React Native CLI app using Stallion, you must first integrate the Stallion SDK and CLI into your project, then publish new JavaScript bundles using the Stallion CLI and promote them via the web console. ### Step-by-Step Guide#### 1. Setup Stallion Account and ProjectCreate an account on the [Stallion Console](https://www.stalliontech.io/react-native-ota-updates-guide) and create a new project and an associated "bucket" (storage container for your bundles).Obtain Project ID and App Token from the Project Settings in your Stallion dashboard. #### 2. Install and Configure the Stallion SDK in Your App - Install the SDK and CLI in your React Native project directory using npm or yarn:```bashnpm install react-native-stallion```or```bashyarn add react-native-stallion```Then, install the necessary pods for iOS:```bashnpx pod-install```- Configure Native Code: You need to modify native files in Android and iOS to use the Stallion bundle path instead of the default one.- Android (MainApplication.kt or MainApplication.java): Override getJSBundleFile to return Stallion.getJSBundleFile(applicationContext).- iOS (AppDelegate.swift or AppDelegate.mm): In the bundleURL method, use StallionModule.getBundleURL() for release builds.- Add your StallionProjectId and StallionAppToken to the app's Info.plist (iOS) and strings.xml (Android) files.- Wrap your main component: In your App.js or App.tsx, wrap your root component with the withStallion Higher-Order Component (HOC).```tsximport { withStallion } from 'react-native-stallion';// ...export default withStallion(App);``` #### 3. Publish and Deploy UpdatesLog in to the CLI: Authenticate your CLI with your Stallion account:```bashnpx stallion login```This will open a web browser to log in, after which you will copy and paste an access token back into the terminal.Publish the JS Bundle: After making JavaScript/TypeScript code changes, use the CLI to build and upload the new bundle to a specific bucket for a target platform:```bashnpx stallion publish-bundle --upload-path=org-name/project-name/bucket-name --platform=android # or ios```You can find the correct bundle path shortcut in the Stallion Console.Promote the Release to Production:- Navigate to the Stallion Console and go to the "Releases" section.- Select the bundle you want to promote and click "Promote Bundle".- Specify the target app version, rollout percentage (e.g., phased rollout), and other details before confirming. #### 4. Testing- To test, you must use a published app build (APK or TestFlight build) with the Stallion SDK integrated, not a development build running off the Metro bundler.- The app will automatically check for updates when it moves from the background to the foreground and apply them on the next restart.- Stallion also provides an in-app testing modal to instantly switch between different bundle versions for QA purposes. Following these steps allows you to push instant JavaScript updates to your users without requiring an app store review process. 